# Описание решения

## Консистентность

Для обеспечения консистентности данных на сервере можно просто регистрировать каждый клик, а статистику вычислять. Однако наша статистика очень простая, поэтому воспользуемся атомарным инкрементом на уровне СУБД. Чтобы данные не расходились, можно инкрементировать только данные по пользователю в конкретном раунде, а общую статистику вычислять и, по завершению раунда, записывать в сам раунд. Это будет теоретически более масштабируемый вариант. Однако, для наших условий - 10 выживших - достаточно будет оба инкремента - счета игрока и счетчика раунад - завернуть в общую транзакцию.

## Интерфейс

На каждый тап будет уходить отдельный запрос. Т.к. подразумевается, что инстансов сервера будет несколько, то есть вероятность, что ответы на запросы будут приходить не в том порядке, в котором мы их отправляем. Чтобы счетчик тапов не дергался на экране игрока, мы будем анализировать данные ответа, прежде чем их отображать. В общем случае нам нужно было бы добавить метку времени, как-то решать вопрос о том, что время клиента и сервера (разных серверов) отличаются, но в нашем случае мы просто проверим абсолютные значения: мы знаем, что они не могут убывать.

## Подсчет кликов

В условиях не оговорено как быть с расхождением времени сервера и клиента, учитывать ли время на прохождение запроса до сервера. Для справедливого подсчета следует учесть эти моменты, однако, думаю, тестовое задание не подразумевает такое усложнение. Определять попал ли клик во временной интервал между стартом и окончанием раунда будем по времени сервера и по факту обработки запроса.

Для определения попадания клика в интервал ходить в базу данных для считывания границ раунда - затратная операция, учитывая что выполнять ее придется на каждый тап. Предположим, что активный раунд не модифицируется и будем кешировать его данные прямо в памяти. Для полноценной реализации, конечно, следует выбрать более подобающую реализацию, исходя из предполагаемой нагрузки.

## Подсчет очков

Правило "Каждый 11-й тап приносит 10 очков" строго математически решаемо иходя из общего количества кликов как score = (count div 11)*9 + count. Если бы условие было более сложным и требовало хранение промежуточного счетчика, для избежания race condition при одновременных запросах на его границе потребовалась бы более хитрое решение, к примеру, запись с блокировкой строки таблицы.


## Время
- Анализ задачи, проектирование решения, начальное описание, создание проекта (1ч)
- Правки для запуска на Supabase (1ч)
- Минимальный, работающий с сервером клиент (1ч)
- Гусь, кликер (1ч)
