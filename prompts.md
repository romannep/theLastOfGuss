Создай в текущей папке проект с названием "The Last of Guss". Проект будет представлять собой игру-кликер и содержать и бэкенд и фронтэнд части. Сейчас надо создать минимальную бэкенд часть. При запуске сервера он должен подключаться с помощью ОРМ Sequelize с базой данных (строка подключения должна считываться из .env файла) и проверять существование таблицы users. Если такая таблица в базе данных отсутствует, сервер должен производить инициализацию базы данных. Для инициализации базы данных в ней необходимо создать таблицы: users (с полями: login, password_hash, role (строка)), rounds (с полями: uuid, start_datetime, end_datetime, status (строка), score (целое число)), scores (с полями: user (ссылка на юзера - запись в таблице users), round (ссылка на раунд - запись в таблице rounds), score (целое число)), а также - создать начальных пользователей так, чтобы они могли войти в систему с указанными паролями (записать нужных password_hash) - login: roma, passwod: roma, role: user; login: alisa, password: alisa, role: user; login: admin, password: admin, role: admin.

Создай JSON API со следующими эндпоинтами: POST /auth - получает на вход username password, проверяет хеш пароля в базе данных, в случае успеха возвращает токен jwt который содержить id пользователя; GET /rounds - проверяет токен, если он невалидный - возвращает ошибку, если валидный возращает всю таблицу rounds; GET /round/:uuid  - проверяет токен, если он невалидный - возвращает ошибку, если валидный возращает запись из таблицы rounds согласно параметру uuid и запись из таблицы score согласно параметру uuid и id пользователя из токена; POST /tap - выводит в консоль "tap performed".

 сделай рефакторинг: пусть в корне будут папки server и client. В папку server перемести текущий код. В папке client сделай заготовку фронтэнд части нашего проекта.

 Клиент нашей игры должен считывать адрес сервера из .env файла и на главной странице должен отображать список Раундов, выполняя запрос к АПИ. Если у клиента нет токена или запрос вернул ошибку - необходимо перейти на страницу авторизации, которая имеет путь /auth и отображает поля для ввода логина и пароля. После успешного ввода пароля и получения токена необходимо переходить на главную страницу.

 Добавь в содержание токена роль пользователя. На сервере создай роут POST /round по которому будет создавться раунд со значениями start_datetime равным текущая дата и время плюс COOLDOWN_DURATION секунд, end_datetime равным текущая дата плюс COOLDOWN_DURATION плюс ROUND_DURATION секунд. COOLDOWN_DURATION и ROUND_DURATION считываем из .env файла. В обработке роута POST /round добавь проверку роли клиента: если роль не равна admin - возвращай ошибку.  На клиенте, если у пользователя роль == admin отображай кнопку "Создать раунд" рядом с кнопкой "Выйти". По этой кнопке выполняется запрос к апи  POST /round.

 На клиенте, при клике на раунд отображать страницу раунда. Если текущее время меньше даты старта раунда - отображать обратный отсчет до начала раунда и картинку guss_stop.png (картинки лежат в client/src/assets). Если текущее время больше даты старта раунда - отображать только статистику рануда и картинку guss_stop.png. Если текущее время находится между временем старта и временем окончания, раунд считается открытым: отображаем картику guss_ready.png, при тапе на картинку гуся (или зажатой левой кнопки мыши) отображаем картинку guss_tapped.png: по каждому тапу (клике) на картинку отправляем запрос на сервер на эндпоинт POST /tap

На сервере доработай модель score: добавь колонку taps типа целое число. На запрос POST /tap выдавай ошибку, если теле запроса нет uuid - uuid раунда. Если uuid указан, то выполни внутри транзакции: найди или создай запись в таблице score c полученными uuid раунда и id пользователя; новое количества поля taps будет равно старому значению плюс 1, новое значение поля score будет равно (Math.floor(taps/11)*9 + taps), выполни запрос к СУБД для атомарного инкремента  полученной записи из таблицы score так, чтобы поля taps и score приняли новые значения, выполни запрос к СУБД для атомарного инкремента поля score записи требуемой строки раунда таблицы rounds на величину увеличения поля score записи таблицы score.

 На клиенте по каждому тапу в тело запроса POST /tap включаем uuid раунда. В ответ на этот запрос клиент получает текущее заработанное количество очков - его нужно выводить вместо собственного счетчика. Если ответ от сервера показывает количество очков меньшее, чем то, которое отображается, то такой ответ мы игнорируем и не обновляем информацию на экране. 

 Доработай эндпоинт GET /round: если раунд завершен, суммируй счет всех игроков и общую сумму добавь в тело запроса, если раунд завершен, определи игрока набравшего самое большое количество очков и добавь его имя и счет в тело запроса, добавь в тело запроса счет текущего пользователя. На клиенте, если раунд завершен, выводи общий счет раунда, имя и счет лучшего игрока и счет текущего игрока. По завершению раунда обнови страницу.
 